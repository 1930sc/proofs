// Generated by IcedCoffeeScript 108.0.11
(function() {
  var ExpansionError, SHA256, check_expansion_kv, check_expansions, hash_obj, json_at_path, json_stringify_sorted, katch, parse3, pgp_utils, prng, triplesec, _ref;

  parse3 = require('./parse3');

  pgp_utils = require('pgp-utils');

  _ref = pgp_utils.util, katch = _ref.katch, json_stringify_sorted = _ref.json_stringify_sorted;

  triplesec = require('triplesec');

  SHA256 = triplesec.hash.SHA256;

  ExpansionError = require('./errors').errors.ExpansionError;

  prng = require('crypto').prng;

  check_expansions = function(_arg) {
    var expansions, k, v, _results;
    expansions = _arg.expansions;
    _results = [];
    for (k in expansions) {
      v = expansions[k];
      _results.push(check_expansion_kv({
        k: k,
        v: v
      }));
    }
    return _results;
  };

  exports.hash_obj = hash_obj = function(o) {
    var s;
    s = json_stringify_sorted(o);
    return (new SHA256).bufhash(Buffer.from(s, 'utf8')).toString('hex');
  };

  check_expansion_kv = function(_arg) {
    var h, k, s, v;
    k = _arg.k, v = _arg.v;
    if (!parse3.is_hex(k, 32)) {
      throw new ExpansionError("bad hash: " + k);
    }
    s = json_stringify_sorted(v);
    if (!/^[\x20-\x7e]+$/.test(s)) {
      throw new ExpansionError("JSON stub has non-ASCII");
    }
    h = (new SHA256).bufhash(Buffer.from(s, 'utf8')).toString('hex');
    if (k !== h) {
      throw new ExpansionError("hashcheck failure in stub import");
    }
  };

  exports.expand_json = function(_arg) {
    var expansions, found, json, k, xform;
    json = _arg.json, expansions = _arg.expansions;
    expansions || (expansions = {});
    if (Object.keys(expansions).length === 0) {
      return json;
    }
    check_expansions({
      expansions: expansions
    });
    found = {};
    xform = function(o) {
      var expansion, k, ret, v, _i, _len;
      if (o == null) {
        return o;
      }
      if (typeof o === 'string' && ((expansion = expansions[o]) != null)) {
        found[o] = true;
        return expansion;
      }
      if (typeof o !== 'object') {
        return o;
      }
      if (Array.isArray(o)) {
        ret = [];
        for (_i = 0, _len = o.length; _i < _len; _i++) {
          v = o[_i];
          ret.push(xform(v));
        }
        return ret;
      }
      ret = {};
      for (k in o) {
        v = o[k];
        ret[k] = xform(v);
      }
      return ret;
    };
    json = xform(json);
    for (k in expansions) {
      if (!found[k]) {
        throw new ExpansionError("Did not find expansion for " + k);
      }
    }
    return json;
  };

  json_at_path = function(_arg) {
    var c, components, json, last_component, path, prev, repl, _i, _len;
    json = _arg.json, path = _arg.path, repl = _arg.repl;
    components = path.split(/\./);
    prev = null;
    last_component = null;
    for (_i = 0, _len = components.length; _i < _len; _i++) {
      c = components[_i];
      prev = json;
      last_component = c;
      json = json[c];
      if (json == null) {
        throw new Error("cannot find path " + path);
      }
    }
    if (repl != null) {
      if ((prev == null) || (last_component == null)) {
        throw new ExpansionError("failed to replace at " + path);
      }
      prev[last_component] = repl;
    }
    return json;
  };

  exports.stub_json = function(_arg) {
    var expansions, h, json, obh, obj, path;
    json = _arg.json, expansions = _arg.expansions, path = _arg.path;
    obj = json_at_path({
      json: json,
      path: path
    });
    obh = JSON.parse(JSON.stringify(obj));
    obj.entropy = prng(16).toString('base64');
    h = hash_obj(obj);
    expansions[h] = obj;
    json_at_path({
      json: json,
      path: path,
      repl: h
    });
    return null;
  };

}).call(this);
